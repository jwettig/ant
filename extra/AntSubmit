#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long;

use Cwd qw(abs_path getcwd);
use File::Path qw(rmtree mkpath);
use File::Basename qw(basename);
use Text::ParseWords;
use POSIX;

my $filelist = '-';             # default STDIN
my $clean = 0;
my $help = 0;
my $cwd = getcwd;
my $jobtag = 'Ant';
my $QSUB_BIN = 'qsub';
my $ANT_BIN = which('Ant');
my $ANT_ARGS = '-b'; # ensure batch mode
my $LOG_DIR = 'log';
my $OUT_DIR = 'root';
my $no_log = 0;

# parse options
Getopt::Long::Configure(qw(gnu_getopt));
GetOptions(
           'help|h' => \$help,
           'clean|c' => \$clean,
           'tag|t=s' => \$jobtag,
           'filelist=s' => \$filelist,
           'no_log' => $no_log
          ) or print_help();
if ($help) {
  print_help();
}

&main;

sub main {
  # check some things before submission
  die "Ant not found in PATH=$ENV{PATH}" unless defined $ANT_BIN;

  # read in additional Ant args
  if (-f "Antrc") {
    open(my $Antrc_fh, "<Antrc") or die "Can't open Antrc: $!";
    while (my $line = <$Antrc_fh>) {
      # remove leading and trailing whitespace
      $line =~ s/^\s+//;
      $line =~ s/\s+$//;
      next if $line eq '';
      next if $line =~ /^#/;
      die "Argument $line in Antrc does not start with -" unless $line =~ /^\-/;
      $ANT_ARGS .= " $line";
    }
    close $Antrc_fh;
  } elsif (@ARGV==0) {
    die "No Antrc found and no additional arguments for Ant provided\n";
  }

  # any additional options to Ant
  for my $arg (@ARGV) {
    die "Optional argument '$arg' does not start with -" unless $arg =~ /^\-/;
    $ANT_ARGS .= " $arg";
  }

  # read in the filelist, check for more errors
  open(my $filelist_fh, "<$filelist") or die "Can't open filelist $filelist: $!\n";
  my $n = 0;
  my @jobs;
 line:
  while (my $line = <$filelist_fh>) {
    $n++;
    # remove leading and trailing whitespace
    $line =~ s/^\s+//;
    $line =~ s/\s+$//;
    my @inputfiles;
    for my $inputfile (parse_line('\s+',0,$line)) {
      unless(-f $inputfile) {
        warn "Warning: Inputfile $inputfile does not exist, skipping.";
        next line;
      }
      unless($inputfile =~ /\.(dat|dat\.xz|root)$/) {
        warn "Warning: Inputfile $inputfile does not end with .dat[.xz] or .root, skipping";
        next line;
      }
      push(@inputfiles, $inputfile);
    }

    next line if @inputfiles==0;


    my $basename = basename($inputfiles[0]);

    my $runnumber = extract_runnumber($inputfiles[0]);
    unless(defined $runnumber) {
      # use line number by default
      $runnumber = $n;
    }
    push(@jobs, {
                 'inputfiles' => \@inputfiles,
                 'jobnumber' => $runnumber,
                 'logfile' => "$LOG_DIR/$basename.log",
                 'outputfile' => "$OUT_DIR/Ant_$basename.root"
                }
        );
  }
  close $filelist_fh;

  my $total = scalar @jobs;
  die "No jobs to be submitted, abort.\n" if $total==0;

  # prepare output dirs
  unless(-d $OUT_DIR) {
    mkpath([$OUT_DIR]) == 1 or die "Cannot create output folder '$OUT_DIR'";
  } else {
    my $n_outfiles = 0;
    my $n_logfiles = 0;
    for my $job (@jobs) {
      my $outputfile = $job->{outputfile};
      if (-f $outputfile) {
        if (!$clean) {
          die "Outputfile $outputfile already exists. Use --clean?\n";
        }
        unlink $outputfile or die "Cannot delete file $outputfile: $!";
        $n_outfiles++;
      }
      my $logfile = $job->{logfile};
      if (-f $logfile) {
        if (!$clean) {
          die "Logfile $logfile already exists. Use --clean?\n";
        }
        unlink $logfile or die "Cannot delete file $logfile: $!";
        $n_logfiles++;
      }
    }
    if ($clean) {
      printf("%04d/%04d output/logfiles cleaned\n", $n_outfiles, $n_logfiles);
    }
  }

  unless(-d $LOG_DIR) {
    mkpath([$LOG_DIR]) == 1 or die "Cannot create log folder '$LOG_DIR'";
  }

  # finally submit the jobs
  my $submitted = 0;
  for my $job (@jobs) {
    submit_job($job);
    $submitted++;
    printf("%-40s\r",sprintf("%04d/%04d = %03.0f %% submitted",$submitted,$total,100*$submitted/$total));
  }
  printf("%-40s\n", "Submitted $submitted jobs.");

  if($no_log) {
    return;
  }

  open(my $fh_log, ">>AntSubmit.log") or die "Can't open AntSubmit.log: $!";
  printf $fh_log "%s: %04d jobs with args '%s'\n", strftime('%Y-%m-%d %H:%M:%S',localtime), $submitted, $ANT_ARGS;
  close $fh_log;
}

sub extract_runnumber {
  my $f = shift;
  if ($f =~ /_(\d+?)\.dat/) {
    return $1;
  }
  return undef;
}

sub which {
  my $cmd = shift;
  open(my $p, "which $cmd |") or die "Can't open which: $!";
  my @lines = <$p>;
  close $p;
  my $exit_value = $? >> 8;
  if ($exit_value != 0 || @lines != 1) {
    return undef;
  }
  chomp $lines[0];
  return $lines[0];
}

sub submit_job {
  my $job = shift;
  my $jobnumber = $job->{jobnumber};

  my $logfile = abs_path($job->{logfile});
  my $user = $ENV{USER};

  my $ant_cmd = "$ANT_BIN $ANT_ARGS";

  for my $inputfile (@{$job->{inputfiles}}) {
    $inputfile = abs_path($inputfile);
    $ant_cmd .= " -i '$inputfile'";
  }
  my $outputfile = abs_path($job->{outputfile});
  $ant_cmd .= " -o '$outputfile'";

  my $qsub_cmd = $QSUB_BIN;

  $qsub_cmd .= " -N '$jobtag/$jobnumber'";

  # mails when job aborts, begins, ends
  #$qsub_cmd .= " -m a -m b -m e";
  #$qsub_cmd .= " -M '$user\@kph.uni-mainz.de'";

  # logging
  $qsub_cmd .= " -j oe -o '$logfile'";

  # misc stuff
  $qsub_cmd .= " -z -q batch -V -l ncpus=1 -l walltime=2:00:00";

  # open pipe to qsub
  open(my $qsub_pipe, "| $qsub_cmd")
    or die "Can't open pipe to $QSUB_BIN: $!";
  print $qsub_pipe $ant_cmd;
  close $qsub_pipe or die "Cannot close pipe to $QSUB_BIN";
}



sub print_help {
  print <<__EOF;
Usage: AntSubmit [--clean] [--tag jobtag] [--filelist filename] -- [optional Ant arguments]

Submit jobs running Ant on files in read from STDIN (or from file list
specified by --filelist), output goes to current directory.

Options:

  --clean     Recursively delete <outputdir> before submission.
  --tag       Specify a custom job tag, default is Ant
  --filelist  Read from file instead of STDIN
__EOF
  exit 255;
}
